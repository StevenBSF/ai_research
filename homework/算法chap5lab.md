![image-20241108133233157](/Users/baoshifeng/Library/Application Support/typora-user-images/image-20241108133233157.png)

## ***计算机学院（国家示范性软件学院）***

# 算法设计与分析实验报告

## 旅行售货员TSP问题

<center>姓名：包诗峰</center>
<center>学号：2022211656</center>
<center>班级：2022211301</center>

<div STYLE="page-break-after: always;"></div> 

## 实验环境

- **C++20**
- **Clion IDE**
- **MacOS**

---

### 1. 实验内容

#### 1.1 题目描述

给定 $n$ 个城市，每两个城市之间的边权重表示旅行路径的费用。旅行商从城市 1 出发，依次经过其他所有城市，仅能经过每个城市一次，并返回城市 1。求一条费用最小的回路路径及其总费用。

#### 1.2 输入格式

输入共 $n + 1$ 行：

- 第一行为一个整数 $n$，表示城市数量。
- 接下来的 $n$ 行每行包含 $n$ 个整数或字符串 "INF"，表示城市间的费用矩阵 $w$。如果两个城市之间不存在边，则用 "INF" 表示无穷大。

#### 1.3 输出格式

输出共两行：

- 第一行为最小回路路径的总费用。
- 第二行为最小回路路径的顺序，从城市 1 开始，经过其他所有城市后回到城市 1。

#### 1.4 输入输出样例

**输入:**

```bash
4
0 10 15 20
10 0 35 25
15 35 0 30
20 25 30 0
```

输出：

```bash
80
1 2 4 3 1
```

#### 1.5 数据范围

- $ 1 \leq n \leq 10 $
- $ 0 \leq w[i][j] \leq 10^6 $，表示城市 $i$ 和 $j$ 间的费用。

---

- ### 2. 实验设计思路

  旅行商问题 (TSP) 是典型的 NP 难问题，其回溯法通过深度优先搜索 (DFS) 遍历所有可能路径。为了减少无效路径的计算，提高算法效率，加入了剪枝策略来提前终止不可能成为最优解的分支。

  ---

  #### 2.1 状态定义

  为了方便在回溯过程中保存和更新路径信息，定义如下状态变量：

  - `x[i]`：表示当前选择的第 $i$ 个城市在路径中的位置索引。例如，当 `x[2] = 3` 时，表示路径的第 2 个城市是编号 3 的城市。
  - `x_best[i]`：表示搜索过程中找到的最优路径序列，保存完整的最小费用路径。
  - `cv`：表示当前已走路径的总费用（current value），随着遍历不同的城市而更新。
  - `v_best`：表示到目前为止找到的最优路径的费用，初始值为无穷大 `INF`。

  ---

  #### 2.2 状态转移方程

  在遍历过程中，从当前路径的末尾城市 $x[i-1]$ 出发，选择一个未访问过的城市 $u$，将其加入路径 `x[i]`，并根据以下规则进行路径转移：

  - **不走向已访问城市或不存在路径的城市**：如果城市 $u$ 已被访问，或者从 $x[i-1]$ 到 $u$ 之间没有路径，则跳过该路径。
  - **尝试走向城市 $u$**：
    - **更新路径费用**：`cv += w[x[i-1]][u]`，表示将从 $x[i-1]$ 到 $u$ 的费用加到当前路径总费用 `cv` 中。
    - **递归搜索下一层**：通过 `TspDFS(i + 1)` 继续向下搜索下一层。
    - **回溯操作**：递归返回时，恢复 `cv` 和 `x[i]` 的状态，确保不影响后续分支的搜索。例如：
      ```cpp
      cv -= w[x[i-1]][u];  // 回溯费用
      x[i] = 0;            // 恢复路径数组
      ```

  ---

  #### 2.3 剪枝条件

  在 DFS 过程中，通过剪枝策略来跳过不必要的搜索分支，从而加快搜索速度：

  1. **当前费用超出最优路径费用**：
     - 当从 $x[i-1]$ 走向 $u$ 后，路径总费用 `cv + w[x[i-1]][u]` 大于等于已知的最优路径费用 `v_best` 时，剪枝该分支，提前返回。
     - 剪枝原因：即便继续搜索下去，该路径的费用也不会比当前最优解更优。

  2. **无回到起点的路径**：
     - 当遍历完所有城市后，若当前路径 `x[n-1]` 到起点 `x[0]` 之间没有路径，则不更新 `v_best`。
     - 剪枝原因：路径不完整，无法形成回路。

  ---

  #### 2.4 边界条件

  - **初始状态**：
    - 起点城市编号为 `0`（即第 1 个城市），因此 `x[0] = 0`。
    - 初始路径费用 `cv = 0`，最优路径费用 `v_best = INF`。

  - **终止条件**：
    - 当遍历到第 $n$ 层（即第 $n$ 个城市）时，说明已经经过所有城市，形成了一条完整路径，需要判断是否存在返回起点的路径：
      - 如果存在，则计算完整路径的总费用，并与 `v_best` 比较，更新最优路径和最优费用。
      - 如果不存在，则直接返回，不更新路径。

  **边界条件代码**：

  ```cpp
  if (i == n) {  // 所有城市都被访问
      if (w[x[n-1]][0] != INF) {  // 存在回到起点的路径
          cv += w[x[n-1]][0];  // 加上返回起点的费用
          if (cv < v_best) {  // 如果找到更优的路径
              v_best = cv;
              copy(x, x + n, x_best);  // 复制当前路径为最优路径
          }
          cv -= w[x[n-1]][0];  // 回溯
      }
      return;  // 结束搜索
  }

---

### 3. 基础算法实现

#### 3.1 代码实现

```cpp
#include <iostream>
#include <algorithm>
#include <climits>
#include <string>

using namespace std;

const int INF = INT_MAX;
const int MAXN = 10;

int n;              // 城市数量
int w[MAXN][MAXN];  // 权重矩阵
int x[MAXN];        // 当前路径
int x_best[MAXN];   // 最优路径
int v_best = INF;   // 最优路径长度
int cv = 0;         // 当前路径长度

void TspDFS(int i) {
    if (i == n) {  // 搜索到叶子节点
        if (w[x[i - 1]][0] != INF) {  // 检查是否有回到出发城市的路径
            cv += w[x[i - 1]][0];
            if (cv < v_best) {  // 更新最优解
                v_best = cv;
                copy(x, x + n, x_best);  // 复制当前路径为最优路径
            }
            cv -= w[x[i - 1]][0];  // 回溯
        }
        return;
    }
    for (int u = 0; u < n; ++u) {  // 遍历所有城市
        if (find(x, x + i, u) == x + i && w[x[i - 1]][u] != INF) {  // 未访问过且存在路径
            int temp = cv + w[x[i - 1]][u];
            if (temp < v_best) {  // 剪枝
                x[i] = u;
                cv = temp;
                TspDFS(i + 1);  // 递归搜索下一层
                cv -= w[x[i - 1]][u];  // 回溯
            }
        }
    }
}

int main() {
    freopen("tsp.in", "r", stdin);
    freopen("tsp.out", "w", stdout);

    cin >> n;

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            string input;
            cin >> input;
            if (input == "INF") {
                w[i][j] = INF;
            } else {
                w[i][j] = stoi(input);
            }
        }
    }

    x[0] = 0;  // 出发城市为0号城市
    TspDFS(1);  // 从第1个位置开始递归

    if (v_best < INF) {
        cout << v_best << "\n";
        for (int i = 0; i < n; ++i) {
            cout << x_best[i] + 1 << " ";
        }
        cout << "1\n";
    } else {
        cout << "不存在回路\n";
    }

    return 0;
}
```

**4. 实验结果**

**4.1 测试用例 1**

输入：

```c++
4
0 10 15 20
10 0 35 25
15 35 0 30
20 25 30 0
```

输出：

```c++
80
1 2 4 3 1
```

**4.1 测试用例 2**

输入：

```c++
5
0 3 1 5 8
3 0 6 7 9
1 6 0 4 2
5 7 4 0 3
8 9 2 3 0
```

输出：

```c++
13
1 3 5 4 2 1
```



## 实验总结

​	•	回溯法通过深度优先搜索遍历所有可能路径，效率较低，但可以得到最优解。

​	•	剪枝策略可以有效减少不必要的路径搜索，提高性能。
