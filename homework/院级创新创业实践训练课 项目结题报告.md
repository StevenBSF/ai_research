**计算机学院（国家示范性软件学院）**

# 院级创新创业实践训练课 项目结题报告

课程名称： *智能车实践训练*

项目名称： *智能循迹避障小车*

项目成员： *蔡逸文，宋健，孟林，包诗峰*

指导教师： *刁 婷*

时间：2024 年 10 月 21 日

|  **班级**  |  **学号**  | **姓名** | **分工**                         | **贡献度** |
| :--------: | :--------: | :------- | :------------------------------- | :--------- |
| 2022211305 | 2022212511 | 蔡逸文   | 小车程序设计，代码和文档撰写     | 25%        |
| 2022211305 | 2022212702 | 宋健     | 小车通信实现，代码撰写           | 25%        |
| 2022211305 | 2022210484 | 孟林     | 小车算法逻辑设计，智能机器人联动 | 25%        |
| 2022211301 | 2022211656 | 包诗峰   | 小车算法逻辑设计，迷宫仿真       | 25%        |

# 1 实验概况

## 1.1 实验内容

1.  编写程序，通过小车红外传感器的返回值，判定赛道现状，实现简单的循迹算法，让小车在慢速状况下实现沿着轨道行驶。

2.  通过超声波传感器和红外传感器获取小车前方障碍物的距离，选取合适的极限距离，通过程序控制小车采取行动避免撞击障碍物。

3.  撰写程序，控制智能小车在迷宫中自主寻找迷宫出口，自主穿越迷宫。

4.  模拟生活场景，实现智能小车智能机械臂的联动，解决生活现实中的问题。

## 1.2 实验要求

1.  设计健壮的循迹算法，让小车适应各种赛道。同时在保证循迹正确的情况下尽可能提高小车的速度。

2.  选取合适的极限距离和避障算法，让小车能及时发现并规避障碍物。

3.  设计正确的寻路和避障算法让小车能正确走出迷宫。

## 1.3 实验开发环境

- Visual Studio Code 19.0

- Go 1.23.1

- VIPLE

# 2 实验设计

## 2.1 硬件说明

智能小车一共有5个可交互硬件部分，其中用户可操控的有两个：左轮和右轮；用户只能接受返回值的有3个：前红外光传感器，红外避障传感器，超声波测距传感器，其功能介绍如下：

- 左轮：对应端口号为6，速度为 -1.0 – 1.0 之间的浮点数

- 右轮：对应端口号为3，速度为 -1.0 – 1.0 之间的浮点数

- 超声波测距传感器：对应端口号为4，返回值为**字符串形式的浮点数，**当没有障碍物时返回空字符串

- 红外避障传感器：对应端口号为2，返回值为整数0 或1，0表示无障碍，1表示有障碍

- 红外光传感器：对应端口号为1，返回值为整数0或1，0表示黑色赛道，1表示非黑色赛道

小车的返回值和接收值均为 *Json* 格式的数据包，格式如下：

![image-1](../../code/Python/CarRobot/image-1.png)

## 2.2 循迹和避障程序设计

### 2.2.1 包和模块说明

程序的包和模块示意图如下

![image-20241021200307800](../../../Library/Application Support/typora-user-images/image-20241021200307800.png)

矩形代表包，圆形代表模块。

### 2.2.2 main

`main`包是程序的入口点，`main` 包会执行程序的初始化，如和小车建立链接，控制小车的状态更新和行驶，当小车不在赛道或遇到障碍时调用相应的处理程序。

```go
package main

import (
	"log"
	"robot_car/car"
)

type Direction = car.Direction

func main() {
	c := car.NewRobotCar()
	err := c.Connect(car.Config{ServerIP: "192.168.0.1", ServerPort: "9999", LogLevel: "DEBUG"})
	if err != nil {
		log.Println(err)
		return
	}
	go c.StateHandler()
	go controlCar(c)
	for {
	}
}

func controlCar(c *car.RobotCar) {
	isRight := func() bool {
		return c.In_road() && !c.Have_obstacle() && (c.GetDistance() > 15)
	}
	if isRight() {
		c.Straight(isRight)
	}
	for {                   
		if !isRight() {
			c.Adjust_direction(isRight)
		}
	}
}

```

`main` 包的函数调用关系如下

![image-20241021200246828](../../../Library/Application Support/typora-user-images/image-20241021200246828.png)

`main` 函数首先调用 `NewRobotCar`，创建一个新的智能车实例，然后使用 `Connect` 和智能车进行链接，最后启动两个协程，一个运行 `StateHandler`，负责接收小车传来的信息和小车的状态更新；另一个运行 `controlCar`，负责控制小车的行驶。

### 2.2.3 car

`car` 包包含了小车的所有相关函数，其中 `carProtocol` 模块负责和小车通信，完成接收小车传来的数据并解码成相应的自定义数据结构，将其余函数传来的参数编码成 *Json* 格式并发送给小车。`car` 模块负责控制小车的行驶，更新小车的状态，循迹和避障算法的实现。

### 2.2.4 核心算法

#### 2.2.4.1 赛道判定

首先要规定小车是否正确行驶在赛道上，将满足以下条件的小车认为是行驶在赛道上的

- 红外避障传感器返回值为 0
- 红外光传感器返回值为 0
- 超声波测距传感器没有返回值或返回值大于 15

在小车行驶过程中，不断检查当前小车是否在赛道上，若不在就调用循迹函数开始循迹。

#### 2.2.4.2 循迹算法

为了更好的适应多边形赛道和曲线弯道，采用**记忆化循迹**方案，当小车偏离赛道时，会根据上一次转弯的方向来决定下一次转弯的方向，小车转弯的方向和上一次转弯的方向相同。下面以左转为例，通过控制小车转弯的时间控制转弯角度：

1. 首先左转 120 度左右，期间如果找到路就停止转弯并退出函数
2. 然后右转 240 度，即相对于开始位置右转 120 度，找到路就退出函数
3. 若是还没找到，左转 120 度回到开始位置，倒车一段时间，进入重复调用循迹函数

为了防止掉头的同时适应大角度弯道，采取了略大于 90 度的 120 度转向角度

#### 2.2.4.3 渐进式加速

由于单传感器的硬件限制，小车无法准确在直线道路上直行，会出现偏移角度，且仅根据传感器的返回值小车无法判断当前是否已经正确直行，所以为了减少由于速度过快导致超出赛道从而循迹失败或者耗费大量的倒车时间，本程序采用渐进式加速算法。

1. 为小车设定一个基准速度，当小车直行时从基准速度开始
2. 经过一段时间，若小车仍然处于赛道上，增大直行速度
3. 直行速度会随着时间的延长逐渐增大直到达到小车速度的上限
4. 若在这期间小车偏离道路则调用循迹函数循迹

通过这个算法，即确保了小车在长直行道路上的行驶速度，又减少了小车因直行速度太快导致超出赛道的风险

## 2.3 迷宫仿真设计

### 2.3.1 实验内容

编程控制智能小车实现自主寻找迷宫出口，尝试选择效率高的算法，让小车用尽量少的时间走出迷宫。由于现实环境中迷宫环境不易搭建，可以利用VIPLE模拟器实现。

### 2.3.2 实验思路和准备

考虑对于仿真迷宫情景，我们采用沿墙右侧定距算法，使用前方和右侧传感器。

算法设计为：

​		1.当前方距离到过近，则向左转；

​		2.当右侧距离过远时，则向右转。

### 2.3.3 程序设计

如图所示，我们的程序设计如下：

（插入图片）

### 2.3.4 仿真环境

本次迷宫仿真实验使用的环境是 VIPLE 自带的 Web2D 模拟器，显示效果如下：

（插入图片）

### 2.3.5 仿真结果

小车在算法驱动下能正确找到出口。

## 2.4 智能机器人联动设计

让小车在正常赛道上行驶，当机械臂将障碍放入赛道后，小车会识别到障碍并绕路行驶，最终重新返回赛道
