**实验 4 使用 MIPS 指令实现冒泡排序法——实验报告**



------





### **一、实验目的**





本实验通过在 MIPSsim 流水线级模拟器上实现并优化冒泡排序，帮助同学：



1. 熟悉 MIPS 整数指令、基本寻址方式与程序控制转移；
2. 掌握静态调度（手动重排指令序列隐藏冒险）的具体技巧；
3. 理解数据定向（Forwarding）在流水线中的作用，并量化其对性能的影响；
4. 在真实统计数据支撑下，学会撰写性能对比分析。







### **二、实验原理**





冒泡排序通过两层嵌套循环多次比较相邻元素并在必要时交换，实现把未排序区间中最大（或最小）元素逐趟“冒”到数组尾部。

在五段式 MIPS 流水（IF-ID-EX-MEM-WB）中，内层循环的核心模式是

```
LW   val1,0(ptr)      # 访问 A[j]
LW   val2,4(ptr)      # 访问 A[j+1]
DSUB r7,val1,val2     # 比较
BLTZ r7,NoSwap        # 条件分支
SW   val2,0(ptr)      # 交换
SW   val1,4(ptr)
```

LW→DSUB 之间天然存在 **load-use RAW 冒险**，BLTZ 又带来 **控制停顿**。

实验采用两种手段减少停顿：



- **数据定向 (Forwarding)** ——让 EX/MEM 或 MEM/WB 输出可以直接回馈给后续指令的 EX 段，硬件级切断大部分寄存器数据冒险；
- **静态调度** ——在软件层面把与比较无依赖的 ADDIU j++、DSUB n-j、SW 等指令插入空档或延迟槽，用“有用工作”覆盖原本的 NOP。







### **三、程序代码清单与注释**







#### **1. 未优化版本（节选）**



```
ADDIU $r1,$r0,n          # n
ADDIU $r2,$r0,0          # i = 0
LOOP1:
    ADDIU $r3,$r0,a      # ptr = &a[0]
    ADDIU $r4,$r0,0      # j = 0
LOOP2:
    LW    $r5,0($r3)
    LW    $r6,4($r3)
    DSUB  $r7,$r5,$r6
    BLTZ  $r7,PASS
    SW    $r6,0($r3)
    SW    $r5,4($r3)
PASS:
    ADDIU $r4,$r4,1
    ADDIU $r3,$r3,4
    DSUB  $r8,$r1,$r4
    BGTZ  $r8,LOOP2
    ADDIU $r2,$r2,1
    DSUB  $r1,$r1,1
    BNE   $r1,$r0,LOOP1
    TEQ   $r0,$r0
```

该实现保持“先取后比再交换”的直观顺序，没有对 LW-use 冒险、分支延迟槽做任何处理，因此在流水模式下会产生大量 RAW 和控制停顿。





#### **2. 静态调度优化版本**



```
ADDIU $r1,$r0,n          # n
ADDIU $r2,$r0,0          # i =0
LOOP1:
    ADDIU $r3,$r0,a
    ADDIU $r4,$r0,0
LOOP2:
    LW    $r5,0($r3)     # A[j]
    LW    $r6,4($r3)     # A[j+1]
    ADDIU $r4,$r4,1      # j++   (填LW-use空档)
    DSUB  $r7,$r5,$r6    # 比较
    DSUB  $r8,$r1,$r4    # n-j   (再次填档)
    BLTZ  $r7,NOSWAP
    SW    $r6,0($r3)     # 分支延迟槽填交换①
    SW    $r5,4($r3)     # 交换②
NOSWAP:
    ADDIU $r3,$r3,4
    BGTZ  $r8,LOOP2
    NOP                   # 无独立指令可用
    ADDIU $r2,$r2,1
    DSUB  $r1,$r1,1
    BNE   $r1,$r0,LOOP1
    NOP
    TEQ   $r0,$r0
```



- j++ 与 n-j 运算被提前至两条 LW 之后，有效隔离 load-use；
- 第一条 SW 被放入 BLTZ 延迟槽，完全掩蔽了控制停顿；
- 整体无新增 NOP，指令条数增加是因为循环展开后的逻辑运算。







### **四、优化后程序代码清单**





> ※完整源文件已在课堂提交，这里仅给出关键循环部分，结构同上 2。





### **五、性能比较与分析**



| **方案** | **是否定向** | **指令数** | **周期** | **CPI**  | **RAW 停顿** | **控制停顿** | **总停顿占比** |
| -------- | ------------ | ---------- | -------- | -------- | ------------ | ------------ | -------------- |
| 未优化   | ✗            | 399        | 804      | 2.02     | 302          | 102          | 50.2 %         |
| 未优化   | ✓            | 399        | 638      | 1.60     | 136          | 102          | 37.3 %         |
| **优化** | **✓**        | 570        | 702      | **1.23** | **10**       | 120          | **18.7 %**     |



- **定向 alone** 即可将 RAW 停顿砍半（302→136），CPI 降至 1.60。
- **再加静态调度** 后，装填指令数 +171，但周期仅回升 64，平均 CPI⇒1.23；RAW 气泡几乎清零（10 cycle，仅占 1.4 %），流水利用率提高到 81 %。
- 控制停顿因分支条数增多略升至 17 %，但对总周期影响很小。





> *附图说明*：附上 MIPSsim 统计窗口三张截图，标注 RAW/控制停顿、执行周期及指令条数，即可直观展示性能梯度。





#### **优化措施与效果归因**





1. **消除 load-use**：通过把 ADDIU/DSUB 插入两条 LW 与比较之间，使 EX 得到的数据不再依赖上一拍的 MEM/WB，RAW 泡全部被抹平。
2. **延迟槽填充**：把一条 SW 移入 BLTZ 延迟槽，分支的固有 1 cycle 停顿转为有效写操作，控制冒险代价部分抵消。
3. **指令并行度提升**：原循环平均 2 cycle 执行 1 条指令；优化后相当于每 1.23 cycle 完成 1 条，吞吐率提高 66 %。





------





### **六、结论**





实验验证了 **“定向 + 静态调度”** 的互补性：硬件转发先削除大部分寄存器冲突，随后手工调度进一步把残余 RAW 与分支延迟槽填满，使总停顿从 50 % 降到不足 20 %，CPU 忙碌度逼近单发射五段流水的理论极限。本次实践不仅巩固了 MIPS 指令语义，也让我们直观体会到编译层“指令级并行”优化的威力，为后续深入学习 superscalar、乱序执行等高级结构奠定了基础。